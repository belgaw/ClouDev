# Лабораторная работа 2

В этой лабе создадим "хорошие" и "плохие" Dockerfiles, опишем плохие практики, пофиксим и расскажем что и почему

## Пример "плохого" Dockerfile

```
FROM ubuntu:latest

RUN apt-get update && apt-get install -y python3 pip

COPY . /app

WORKDIR /app

RUN pip install -r requirements.txt

CMD python3 app.py

```

### А минусы где?
1. Образ `ubuntu:latest` содержит много ненужных нам библиотек и файлов, что увеличит размер контейнера.

2. Команда `RUN apt-get update && apt-get install -y python3 pip` не фиксирована на конкретных версиях, это может привести к проблемам с совместимостью при обновлении пакетов.

3. Если не использовать флаг `--no-cache-dir` при установке Python-библиотек, то кэш может занимать слишком много места в контейнере.

## Пример "хорошего" Dockerfile

```
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python3", "app.py"]


```
### Что поменяли

1. Использование минималистичного образа `python:3.9-slim` значительно уменьшит размер контейнера, потому что содержит только нужные нам(мне) библиотеки для Python-приложений.

2. В "хорошем" Dockerfile используется образ `python:3.9-slim`, который содержит нужные инструменты, избегая ненужной установки через `apt-get`.

3. Использование `pip install --no-cache-dir -r requirements.txt` позволяет избежать накопления ненужных файлов, что уменьшает финальный размер образа.


##  Плохие практики при работе с контейнерами

* Запуск контейнера с root-привилегиями:
  
  Если кто-то получит доступ к контейнеру, он сможет выполнять команды от имени администратора.
  

* Игнорирование мониторинга ресурсов контейнера:

  Неправильное управление ресурсами(процессора, памяти и тд) может привести к нестабильности системы, тем более если контейнеры работают в среде с ограниченными ресурсами.
  

# *

## "Плохой" Docker Compose файл

```
version: '3'

services:
  app:
    build: .
    ports:
      - "80:80"
    volumes:
      - .:/app
    environment:
      - DEBUG=true
  db:
    image: mysql
    environment:
      - MYSQL_ROOT_PASSWORD=password
    ports:
      - "3306:3306"

```

1. Задание пароля напрямую в файле может привести к утечке данных.

2. Открытие портов наружу, особенно для бд, подвергает систему риску атаки.

3. Монтирование каталога хоста в контейнер может привести к проблемам с безопасностью.

## "Хороший" Docker Compose файл

```
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - ./app:/app:ro
    environment:
      - DEBUG=false
    depends_on:
      - db
    networks:
      - app-net

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: strong_password
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - app-net

networks:
  app-net:
    driver: bridge

volumes:
  db_data:

```

1. Пароли можно хранить в .env файле или использовать секреты Docker для большей безопасности.

2. Мы используем внутреннюю сеть `networks`, чтобы контейнеры взаимодействовали только между собой, а порты скрывались от внешних пользователей.

3. Монтируем каталог с флагом ro(только для чтения), чтобы избежать изменений файлов внутри контейнера.


### Изоляция контейнеров


  Чтоб контейнеры не "видели" друг друга по сети, мы настроили `app-net` в режиме `bridge`. В этом режиме контейнеры взаимодействуют только внутри этой сети, а их порты не будут доступны извне(если это не задано в конфигурации).
